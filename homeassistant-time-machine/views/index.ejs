<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
  <link rel="icon" href="<%= url('/favicon.ico') %>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geist:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="<%= url('/static/css/style.css') %>">
  <script>
    // Set theme immediately (before <body> exists) to prevent flash
    const savedTheme = localStorage.getItem('theme') || 'dark';
    const root = document.documentElement;
    root.setAttribute('data-theme', savedTheme);
    root.style.colorScheme = savedTheme === 'light' ? 'light' : 'dark';
    root.classList.add('theme-preload');
    window.__initialTheme = savedTheme;
  </script>
  <script defer src="<%= url('/static/js/strings.js?v=2.9.270') %>"></script>
</head>
<body data-esphome-enabled="<%= esphomeEnabled ? 'true' : 'false' %>" data-packages-enabled="<%= packagesEnabled ? 'true' : 'false' %>">
  <script>
    (function applyInitialTheme(theme) {
      const normalized = theme === 'light' ? 'light' : 'dark';
      const root = document.documentElement;
      root.setAttribute('data-theme', normalized);
      root.style.colorScheme = normalized;
      document.body.setAttribute('data-theme', normalized);
      document.body.style.colorScheme = normalized;
      requestAnimationFrame(() => {
        root.classList.remove('theme-preload');
      });
    })(window.__initialTheme);
  </script>
  <!-- Notification Toast -->
  <div id="notification" class="notification" style="display: none;"></div>

  <!-- Diff Viewer Modal -->
  <div id="diffModal" class="modal" style="display: none;">
    <div class="modal-backdrop"></div>
    <div class="modal-dialog">
      <div class="modal-header">
        <div>
          <h2 id="diffTitle">Compare Configuration</h2>
          <p id="diffSubtitle" style="font-size: 14px; color: #9ca3af;"></p>
        </div>
        <button id="closeDiff" class="close-btn">&times;</button>
      </div>
      <div class="modal-body modal-body--diff" id="diffModalBody">
        <!-- Content will be dynamically inserted based on status -->
      </div>
      <div class="modal-footer modal-footer--diff">
        <button id="cancelDiff" class="btn-secondary">Cancel</button>
        <button id="restoreBtn" class="btn-primary">Restore This Version</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal" style="display: none;">
    <div class="modal-backdrop"></div>
    <div class="settings-card">
      <form id="settingsForm">
          <h2 id="settingsTitle"></h2>

        <div id="haConnectionFields" class="ha-connection-fields">
          <div class="form-group form-group--stacked" style="margin-bottom: 0;">
            <label for="haUrl" id="haUrlLabel">Home Assistant URL</label>
            <input type="text" id="haUrl" placeholder="http://homeassistant.local:8123">
            <p id="haUrlError" class="settings-error-text"></p>
          </div>

          <div class="form-group form-group--stacked">
            <label for="haToken" id="haTokenLabel">Long-Lived Access Token</label>
            <input type="password" id="haToken" placeholder="Enter your long-lived access token">
            <p id="haTokenError" class="settings-error-text"></p>
            <button type="button" id="testConnection" class="btn-secondary settings-inline-btn" style="margin-top: 0;">Test Connection</button>
            <p id="connectionStatus" class="settings-inline-text"></p>
          </div>
        </div>

        <div class="form-group form-group--stacked" style="margin-bottom: 0;">
          <label for="liveConfigPath" id="liveConfigPathLabel">Config Folder Path</label>
          <input type="text" id="liveConfigPath" value="/config">
          <p id="liveConfigPathError" class="settings-error-text"></p>
        </div>

        <div class="form-group form-group--stacked">
          <label for="backupFolderPath" id="backupFolderPathLabel">Backup Folder Path</label>
          <input type="text" id="backupFolderPath" value="/media/timemachine">
          <p id="backupFolderPathError" class="settings-error-text"></p>
          <button type="button" id="backupNow" class="btn-secondary settings-inline-btn" style="margin-top: 0;">Backup Now</button>
          <p id="backupStatus" class="settings-inline-text"></p>
        </div>

        <!-- Git-based Backup Settings -->
        <div class="form-group form-group--stacked">
          <label for="backupMode">Backup Mode</label>
          <select id="backupMode">
            <option value="folder">Folder Mode (Traditional)</option>
            <option value="git">Git Mode (Recommended)</option>
          </select>
          <p style="font-size: 0.875rem; color: #9ca3af; margin-top: 8px; margin-bottom: 0;">
            Git mode provides efficient storage with version control. Folder mode uses traditional timestamped folders.
          </p>
        </div>

        <div id="gitModeSettings" style="display: none; margin-top: 12px;">
          <div class="form-group toggle-group" style="margin-bottom: 0;">
            <label>Enable Auto-Save</label>
            <label class="toggle">
              <input type="checkbox" id="fileWatchingEnabled">
              <span class="toggle-slider"></span>
            </label>
          </div>
          <p style="font-size: 0.875rem; color: #9ca3af; margin-top: 8px; margin-bottom: 12px;">
            Automatically create backups when config files are modified
          </p>

          <div id="fileWatchingOptions" style="display: none; margin-top: 12px;">
            <div class="form-group form-group--stacked">
              <label for="fileWatchingDebounce">Debounce Time</label>
              <select id="fileWatchingDebounce">
                <option value="30">30 seconds</option>
                <option value="60" selected>60 seconds (recommended)</option>
                <option value="120">2 minutes</option>
                <option value="300">5 minutes</option>
              </select>
              <p style="font-size: 0.875rem; color: #9ca3af; margin-top: 8px; margin-bottom: 0;">
                Wait time after last file change before creating backup
              </p>
            </div>
          </div>
        </div>

        <div class="form-group toggle-group" style="margin-bottom: 0; margin-top: 20px;">
          <label id="enableScheduledBackupLabel">Enable Scheduled Backup</label>
          <label class="toggle">
            <input type="checkbox" id="scheduleEnabled">
            <span class="toggle-slider"></span>
          </label>
        </div>

        <div id="scheduleOptions" class="settings-schedule" style="display: none; margin: 0 !important;" data-frequency="daily">
          <div class="form-row">
            <div class="form-group">
              <label for="scheduleFrequency" id="frequencyLabel">Frequency</label>
              <select id="scheduleFrequency">
                <option value="daily" selected>Daily</option>
                <option value="hourly">Hourly</option>
                <option value="weekly">Weekly</option>
              </select>
              <p id="scheduleFrequencyError" class="settings-error-text"></p>
              <style>
                #scheduleFrequency:focus {
                  outline: none !important;
                  box-shadow: none !important;
                }
              </style>
            </div>
            <div class="form-group" id="scheduleTimeGroup">
              <label for="scheduleTime" id="timeLabel">Time</label>
              <input type="time" id="scheduleTime" value="00:00" class="time-input">
              <p id="scheduleTimeError" class="settings-error-text"></p>
            </div>
            <div class="form-group" id="scheduleDayGroup" style="display: none;">
              <label for="scheduleDay" id="dayLabel">Day</label>
              <select id="scheduleDay">
                <option value="0">Sunday</option>
                <option value="1">Monday</option>
                <option value="2">Tuesday</option>
                <option value="3">Wednesday</option>
                <option value="4">Thursday</option>
                <option value="5">Friday</option>
                <option value="6">Saturday</option>
              </select>
              <p id="scheduleDayError" class="settings-error-text"></p>
            </div>
          </div>
        </div>

        <div id="maxBackupsSection" style="display: none; margin: 0 !important; padding-top: 0 !important;">
          <div class="form-group toggle-group" style="margin-bottom: 0;">
            <label id="maxBackupsLabel">Max Backups</label>
            <label class="toggle">
              <input type="checkbox" id="maxBackupsEnabled">
              <span class="toggle-slider"></span>
            </label>
          </div>

          <div id="maxBackupsOptions" class="settings-schedule" style="display: none; margin-top: 0 !important;">
            <div class="form-group">
              <label for="maxBackupsCount" id="maxBackupsCountLabel">Backups to Keep</label>
              <input type="number" id="maxBackupsCount" min="1" max="9999" value="100" placeholder="100">
              <p id="maxBackupsCountError" class="settings-error-text"></p>
              <style>
                #maxBackupsCount::-webkit-inner-spin-button,
                #maxBackupsCount::-webkit-outer-spin-button {
                  display: none;
                  margin: 0;
                  height: 20px;
                  position: relative;
                  right: 4px;
                }
                #maxBackupsCount {
                  -webkit-appearance: textfield;
                  -moz-appearance: textfield;
                  appearance: textfield;
                }
              </style>
            </div>
          </div>
        </div>

        <div class="settings-actions">
          <button type="button" id="cancelSettings" class="btn-secondary">Cancel</button>
          <button type="submit" class="btn-primary">Save</button>
        </div>
      </form>
    </div>
  </div>

  <div class="container">
    <header class="header">
      <div class="header-content">
        <img src="<%= url('/static/images/icon.png') %>" alt="Logo" class="logo" onerror="this.style.display='none'">
        <div>
          <h1>Home Assistant Time Machine</h1>
          <p class="version" id="heroSubtitle"></p>
        </div>
      </div>
      <button id="settingsBtn" class="btn-secondary">Settings</button>
    </header>

    <div class="tabs">
      <button class="tab" data-tab="files" id="filesTab">
        <svg style="width: 16px; height: 16px; margin-right: 6px; vertical-align: -2px;" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
        </svg>
        Files
      </button>
      <button class="tab active" data-tab="backups" id="backupsTab">
        Backups
        <svg class="tab-chevron" style="width: 14px; height: 14px; margin-left: 6px; vertical-align: -2px;" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
        </svg>
      </button>
    </div>

    <div class="subtabs" id="subtabs">
      <button class="subtab active" data-tab="automations" id="automationsTab">Automations</button>
      <button class="subtab" data-tab="scripts" id="scriptsTab">Scripts</button>
      <button class="subtab" data-tab="lovelace" id="lovelaceTab">Lovelace</button>
      <button class="subtab" data-tab="esphome" id="esphomeTab" <% if (!esphomeEnabled) { %>style="display: none;"<% } %>>ESPHome</button>
      <button class="subtab" data-tab="packages" id="packagesTab" <% if (!packagesEnabled) { %>style="display: none;"<% } %>>Packages</button>
    </div>

    <!-- Standard 2-panel layout for backups -->
    <div class="content" id="standardContent">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-header-info">
            <h2 id="backupsTitle">Backups</h2>
            <p id="backupCount">Loading...</p>
          </div>
        </div>
        <div id="backupList" class="list">
          <p class="loading">Loading backups...</p>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <div class="panel-header-top">
            <div class="panel-header-info">
              <h2 id="itemsTitle">Select a backup</h2>
              <p id="itemsSubtitle"></p>
            </div>
            <div class="panel-header-actions">
              <select id="sortSelect" class="select">
                <option value="default">Default Order</option>
                <option value="alpha-asc">A → Z</option>
                <option value="alpha-desc">Z → A</option>
              </select>
            </div>
          </div>
          <div class="search-section">
            <svg class="search-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <input type="text" id="searchBox" class="search-input" placeholder="Search...">
          </div>
        </div>
        <div id="itemsList" class="list">
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
            </div>
            <p class="empty-state-message">Select a backup to view <%= currentMode === 'lovelace' ? 'Lovelace files' : currentMode === 'esphome' ? 'ESPHome files' : currentMode === 'packages' ? 'Packages files' : currentMode %></p>
          </div>
        </div>
      </div>
    </div>

    <!-- Files 3-panel layout -->
    <div class="files-content" id="filesContent" style="display: none;">
      <div class="panel panel--files">
        <div class="panel-header">
          <div class="panel-header-info">
            <h2>File Tree</h2>
            <p id="fileTreeCount">Loading...</p>
          </div>
        </div>
        <div id="fileTree" class="file-tree">
          <p class="loading">Loading file tree...</p>
        </div>
      </div>

      <div class="panel panel--files">
        <div class="panel-header">
          <div class="panel-header-info">
            <h2 id="fileHistoryTitle">Select a file</h2>
            <p id="fileHistoryCount"></p>
          </div>
        </div>
        <div id="fileHistory" class="file-history">
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <p class="empty-state-message">Select a file to view its history</p>
          </div>
        </div>
      </div>

      <div class="panel panel--files">
        <div class="panel-header">
          <div class="panel-header-info">
            <h2 id="fileDiffTitle">Select a commit</h2>
            <p id="fileDiffSubtitle"></p>
          </div>
        </div>
        <div id="fileDiffViewer" class="file-diff">
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
            </div>
            <p class="empty-state-message">Select a commit to view changes</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Base path for all API calls
    const BASE_PATH = <%= JSON.stringify(ingressPath || '') %>;
    const url = (path) => BASE_PATH + path;

    console.log('[app] Loaded! v' + <%= JSON.stringify(version) %>);
    console.log('[app] Base path:', BASE_PATH || '(direct access)');

    // State
    let currentMode = 'automations';
    let currentBackupPath = null;
    let currentBackupName = null;
    let allItems = [];
    let liveItemsMap = {};
    let itemStatuses = {};
    let selectedItem = null;
    let haConfig = null;
    let currentTextStyle = 'default';
    let currentTheme = document.body.dataset.theme || document.documentElement.dataset.theme || 'dark';
    let esphomeFeatureEnabled = document.body.dataset.esphomeEnabled === 'true';
    let packagesFeatureEnabled = document.body.dataset.packagesEnabled === 'true';

    // Files mode state
    let fileTreeData = null;
    let selectedFilePath = null;
    let selectedCommitHash = null;
    let fileHistoryData = [];

    if (!document.body.dataset.theme) {
      document.body.dataset.theme = currentTheme;
      document.body.style.colorScheme = currentTheme;
    }
    if (!document.documentElement.dataset.theme) {
      document.documentElement.dataset.theme = currentTheme;
      document.documentElement.style.colorScheme = currentTheme;
    }

    const TEXT_STYLE_TONES = {
      default: {
        prefix: { success: '', info: '', error: '' },
        suffix: { success: '', info: '', error: '' },
      },
      pirate: {
        prefix: { success: 'Ahoy! ', info: 'Listen up, matey: ', error: 'Blimey! ' },
        suffix: { success: '', info: '', error: '' },
      },
      hacker: {
        prefix: { success: 'Access confirmed: ', info: 'Signal: ', error: 'Alert: ' },
        suffix: { success: '', info: '', error: '' },
      },
      noir_detective: {
        prefix: { success: 'Case file: ', info: 'Here’s the brief: ', error: 'Heads-up, kid: ' },
        suffix: { success: '', info: '', error: '' },
      },
      personal_trainer: {
        prefix: { success: 'CRUSHED IT! ', info: 'LISTEN UP! ', error: 'NO EXCUSES! ' },
        suffix: { success: ' DOMINATION COMPLETE!', info: ' GET AFTER IT!', error: ' FIX IT NOW!' },
      },
      scooby_doo: {
        prefix: { success: 'Zoinks! ', info: 'Jinkies! ', error: 'Ruh-roh! ' },
        suffix: { success: ' Scoob!', info: ', gang!', error: '!' },
      },
    };

    const SETTINGS_MESSAGE_LOOKUP = {
      directory_not_found: 'ui.settingsMessages.directoryNotFound',
      not_directory: 'ui.settingsMessages.notDirectory',
      missing_automations: 'ui.settingsMessages.missingAutomations',
      cannot_access: 'ui.settingsMessages.cannotAccess',
      backup_dir_unwritable: 'ui.settingsMessages.backupDirUnwritable',
      backup_dir_create_failed: 'ui.settingsMessages.backupDirCreateFailed',
      BACKUP_DIR_UNWRITABLE: 'ui.settingsMessages.backupDirUnwritable',
      BACKUP_DIR_CREATE_FAILED: 'ui.settingsMessages.backupDirCreateFailed',
      BACKUP_FAILED: 'ui.settingsMessages.unknownError',
      unknown: 'ui.settingsMessages.unknownError'
    };

    function getSettingsMessageFromCode(code, replacements = {}) {
      if (!code) return '';
      const key = SETTINGS_MESSAGE_LOOKUP[code] || 'ui.settingsMessages.unknownError';
      const sanitized = {};
      Object.entries(replacements || {}).forEach(([k, v]) => {
        if (v !== undefined && v !== null && v !== '') {
          sanitized[k] = v;
        }
      });
      return getStyledText(key, sanitized);
    }

    function applyTheme(theme) {
      const normalized = theme === 'light' ? 'light' : 'dark';
      const root = document.documentElement;
      root.classList.add('theme-transition-suppress');
      root.setAttribute('data-theme', normalized);
      root.style.colorScheme = normalized;
      document.body.dataset.theme = normalized;
      document.body.style.colorScheme = normalized;
      currentTheme = normalized;
      localStorage.setItem('theme', normalized);
      requestAnimationFrame(() => {
        root.classList.remove('theme-transition-suppress');
      });
    }

    function waitForStrings(timeoutMs = 3000) {
      if (window.STRINGS) return Promise.resolve();

      return new Promise((resolve) => {
        const start = Date.now();
        const tick = () => {
          if (window.STRINGS) {
            resolve();
          } else if (Date.now() - start >= timeoutMs) {
            console.warn('[ui] STRINGS failed to load before timeout');
            resolve();
          } else {
            requestAnimationFrame(tick);
          }
        };
        tick();
      });
    }

    function updateUIText() {
      if (!window.STRINGS) {
        console.warn('[ui] STRINGS not loaded yet, skipping text update');
        return;
      }
      if (!document.getElementById('settingsTitle')) {
        console.warn('[ui] Settings modal not in DOM yet, skipping text update');
        return;
      }
      // Update settings modal elements
      document.getElementById('settingsTitle').textContent = getStyledText('ui.settings.title');
      document.getElementById('haUrlLabel').textContent = getStyledText('ui.settings.haUrlLabel');
      document.getElementById('haTokenLabel').textContent = getStyledText('ui.settings.haTokenLabel');
      document.getElementById('liveConfigPathLabel').textContent = getStyledText('ui.settings.liveConfigPathLabel');
      document.getElementById('backupFolderPathLabel').textContent = getStyledText('ui.settings.backupFolderPathLabel');
      document.getElementById('enableScheduledBackupLabel').textContent = getStyledText('ui.settings.enableScheduledBackup');
      document.getElementById('frequencyLabel').textContent = getStyledText('ui.settings.frequencyLabel');
      document.getElementById('timeLabel').textContent = getStyledText('ui.settings.timeLabel');
      const dayLabel = document.getElementById('dayLabel');
      if (dayLabel) dayLabel.textContent = 'Day'; // This could be made dynamic too
      document.getElementById('maxBackupsLabel').textContent = getStyledText('ui.labels.maxBackups');
      document.getElementById('maxBackupsCountLabel').textContent = getStyledText('ui.labels.backupsToKeep');
      
      // Update tab buttons
      document.getElementById('automationsTab').textContent = getStyledText('ui.buttons.automations');
      document.getElementById('scriptsTab').textContent = getStyledText('ui.buttons.scripts');
      document.getElementById('lovelaceTab').textContent = getStyledText('ui.buttons.lovelace');
      document.getElementById('esphomeTab').textContent = getStyledText('ui.buttons.esphome');
      document.getElementById('packagesTab').textContent = getStyledText('ui.buttons.packages');
      document.getElementById('settingsBtn').textContent = getStyledText('ui.buttons.settings');
      
      // Update main panel titles
      document.getElementById('backupsTitle').textContent = getStyledText('ui.labels.backups');
      
      // Update sort options
      const sortSelect = document.getElementById('sortSelect');
      if (sortSelect) {
        const options = sortSelect.options;
        if (options[0]) options[0].textContent = getStyledText('ui.labels.sortDefault');
        if (options[1]) options[1].textContent = getStyledText('ui.labels.sortAlphaAsc');
        if (options[2]) options[2].textContent = getStyledText('ui.labels.sortAlphaDesc');
      }
      
      // Update buttons in settings modal
      document.getElementById('testConnection').textContent = getStyledText('ui.buttons.testConnection');
      document.getElementById('backupNow').textContent = getStyledText('ui.buttons.backupNow');
      document.getElementById('cancelSettings').textContent = getStyledText('ui.buttons.cancel');
      
      // Update save button (this is inside the form submit handler, so we need to find it differently)
      const saveBtn = document.querySelector('#settingsForm button[type="submit"]');
      if (saveBtn) saveBtn.textContent = getStyledText('ui.buttons.save');
      
      // Update restore button text
      document.getElementById('restoreBtn').textContent = getStyledText('ui.buttons.restore');
      
      // Update placeholders
      updatePlaceholders();
    }

    function getStyledText(path, replacements = {}) {
      if (!window.STRINGS) {
        return '';
      }

      const keys = path.split('.');
      let value = window.STRINGS;
      
      for (const key of keys) {
        value = value?.[key];
      }
      
      if (!value) return '';
      if (typeof value === 'string') {
        return value;
      }

      const styledText = value[currentTextStyle] || value.default || '';

      // Replace placeholders like {mode}, {error}, etc.
      return styledText.replace(/{(\w+)}/g, (match, key) => {
        return replacements[key] || match;
      });
    }

    function applyTextStyle(message, tone = 'info') {
      if (!message) return '';
      const toneKey = tone === 'error' ? 'error' : tone === 'success' ? 'success' : 'info';
      const styleKey = TEXT_STYLE_TONES[currentTextStyle] ? currentTextStyle : 'default';
      const config = TEXT_STYLE_TONES[styleKey] || TEXT_STYLE_TONES.default;
      const prefix = (config.prefix && (config.prefix[toneKey] ?? config.prefix.info ?? '')) || '';
      const suffix = (config.suffix && (config.suffix[toneKey] ?? config.suffix.info ?? '')) || '';
      return `${prefix}${message}${suffix}`;
    }

    function getEsphomeDisabledMessage() {
      return getStyledText('ui.esphome.disabled') || 'ESPHome backups are disabled. Enable them in Settings to view files.';
    }

    function getPackagesDisabledMessage() {
      return getStyledText('ui.packages.disabled') || 'Packages backups are disabled. Enable them in the add-on configuration to view files.';
    }

    function updateEsphomeVisibility() {
      const esphomeTab = document.getElementById('esphomeTab');
      if (esphomeTab) {
        esphomeTab.style.display = esphomeFeatureEnabled ? 'inline-block' : 'none';
      }
    }

    function updatePackagesVisibility() {
      const packagesTab = document.getElementById('packagesTab');
      if (packagesTab) {
        packagesTab.style.display = packagesFeatureEnabled ? 'inline-block' : 'none';
      }
    }

    const describeAuthSource = (mode) => {
      switch (mode) {
        case 'supervisor':
          return 'automatic Home Assistant credentials';
        case 'env':
          return 'environment credentials';
        case 'stored':
          return 'saved credentials';
        case 'manual':
          return 'manual credentials';
        default:
          return 'credentials';
      }
    };

    // Load HA config from server
    async function loadAppSettings() {
      try {
        const response = await fetch(url('/api/app-settings'));
        if (response.ok) {
          haConfig = await response.json();
          console.log('[loadAppSettings] Received haConfig from server:', {
            backupMode: haConfig.backupMode,
            fileWatchingEnabled: haConfig.fileWatchingEnabled,
            fileWatchingDebounce: haConfig.fileWatchingDebounce,
            watchedPaths: haConfig.watchedPaths
          });
          await waitForStrings();
          currentTextStyle = haConfig?.textStyle || 'default';
          applyTheme(haConfig?.theme);
          esphomeFeatureEnabled = !!haConfig?.esphomeEnabled;
          updateEsphomeVisibility();
          packagesFeatureEnabled = !!haConfig?.packagesEnabled;
          updatePackagesVisibility();
          document.getElementById('heroSubtitle').textContent = getStyledText('ui.hero.subtitle');
          document.getElementById('itemsSubtitle').textContent = getStyledText('ui.itemsList.noBackupSelected');
          updateUIText(); // Update all UI text elements
        }
      } catch (error) {
        console.error('Failed to load app settings:', error);
      }
    }

    // Notification system
    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      notification.textContent = applyTextStyle(message, type);
      notification.className = `notification ${type}`;
      notification.style.display = 'block';
      
      setTimeout(() => {
        notification.style.display = 'none';
      }, type === 'error' ? 5000 : 3000);
    }

    function showRestartNotification(message, haConfig) {
      const notification = document.getElementById('notification');
      const canRestart = !!(haConfig && haConfig.haAuthConfigured);
      const restartLabel = getStyledText('notifications.restartButton') || 'Restart';
      const manualMessage = getStyledText('notifications.restartManually') || 'Restart from Home Assistant when ready.';
      const tone = canRestart ? 'success' : 'info';
      const formattedMessage = applyTextStyle(message, tone);
      const manualNote = canRestart ? '' : ` ${applyTextStyle(manualMessage, 'info')}`;

      notification.innerHTML = `
        <span>${formattedMessage}${manualNote}</span>
        <button id="restartHaBtn" style="margin-left: 10px; background-color: transparent; color: white; border: 1px solid rgba(255, 255, 255, 0.3); cursor: pointer; font-weight: 500; border-radius: 8px; padding: 4px 8px;">${restartLabel}</button>
      `;
      notification.className = `notification ${tone}`;
      notification.style.display = 'flex';

      const restartBtn = document.getElementById('restartHaBtn');

      if (canRestart) {
        restartBtn.onclick = async () => {
          notification.style.display = 'none';
          showNotification(getStyledText('notifications.haRestarting') || 'Home Assistant is restarting...', 'info');
          try {
            const response = await fetch(url('/api/reload-home-assistant'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ service: 'homeassistant.restart' })
            });
            if (!response.ok) {
              const error = await response.json().catch(() => ({}));
              throw new Error(error.error || 'Restart failed');
            }
            showNotification(getStyledText('notifications.haRestarted') || 'Home Assistant restarted successfully!', 'success');
          } catch (error) {
            console.error('[restart-ha] Error:', error);
            showNotification(getStyledText('notifications.errorRestartingHA', { error: error.message }) || ('Error restarting Home Assistant: ' + error.message), 'error');
          }
        };
      } else {
        restartBtn.onclick = () => {
          notification.style.display = 'none';
          showNotification(manualMessage, 'info');
        };
      }

      setTimeout(() => {
        notification.style.display = 'none';
      }, 8000);
    }

    // Update search placeholder based on mode
    function updatePlaceholders() {
      const searchBox = document.getElementById('searchBox');
      const currentTabName = getStyledText(`ui.buttons.${currentMode}`) || currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      searchBox.placeholder = getStyledText('ui.placeholders.search', { mode: currentTabName });
      
      // Update HA input placeholders
      const haUrlInput = document.getElementById('haUrl');
      const haTokenInput = document.getElementById('haToken');
      if (haUrlInput) haUrlInput.placeholder = getStyledText('ui.placeholders.managedByHA');
      if (haTokenInput) haTokenInput.placeholder = getStyledText('ui.placeholders.managedByHA');
    }
    
    // Format backup folder name to date/time
    // Handles format: YYYY-MM-DD-HHMMSS (e.g., 2025-10-17-085000)
    function formatFolderName(folderName) {
      let date;
      // Try parsing YYYY-MM-DD-HHMMSS
      if (/^\d{4}-\d{2}-\d{2}-\d{6}$/.test(folderName)) {
        const year = parseInt(folderName.substring(0, 4));
        const month = parseInt(folderName.substring(5, 7)) - 1;
        const day = parseInt(folderName.substring(8, 10));
        const hour = parseInt(folderName.substring(11, 13));
        const minute = parseInt(folderName.substring(13, 15));
        const second = parseInt(folderName.substring(15, 17));
        date = new Date(year, month, day, hour, minute, second);
      } else if (/^\d{12}$/.test(folderName)) {
        // Try parsing YYYYMMDDHHmm
        const year = parseInt(folderName.substring(0, 4));
        const month = parseInt(folderName.substring(4, 6)) - 1;
        const day = parseInt(folderName.substring(6, 8));
        const hour = parseInt(folderName.substring(8, 10));
        const minute = parseInt(folderName.substring(10, 12));
        date = new Date(year, month, day, hour, minute);
      } else {
        // Fallback for unknown formats
        return folderName;
      }

      if (isNaN(date.getTime())) {
        return folderName; // Invalid date, return original name
      }

      const formattedDate = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: '2-digit',
        year: 'numeric',
      }).format(date);
      
      const formattedTime = new Intl.DateTimeFormat('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      }).format(date);
      
      return `${formattedDate} at ${formattedTime}`;
    }

    // Format backup name
    function formatBackupName(folderName) {
      const year = folderName.substring(0, 4);
      const month = folderName.substring(4, 6);
      const day = folderName.substring(6, 8);
      const hour = folderName.substring(8, 10);
      const minute = folderName.substring(10, 12);
      
      const date = new Date(year, month - 1, day, hour, minute);
      return new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: '2-digit',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      }).format(date);
    }

    // Load backups
    async function loadBackups() {
      try {
        const backupRootPath = haConfig?.backupFolderPath || '/media/timemachine';
        const response = await fetch(url('/api/scan-backups'), { 
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupRootPath })
        });
        const data = await response.json();
        console.log('[loadBackups] Scan response data:', data);
        
        const backupList = document.getElementById('backupList');
        const backupCount = document.getElementById('backupCount');
        
        if (data.backups && data.backups.length > 0) {
          backupCount.textContent = getStyledText('ui.backupList.snapshotsAvailable', { count: data.backups.length });
          
          backupList.innerHTML = `<div style="display: flex; flex-direction: column; gap: 8px;">` + 
            data.backups.map((backup, index) => {
              const isSelected = currentBackupPath === backup.path;
              const isLightMode = currentTheme === 'light';
              const bgColor = isSelected ? '#007AFC' : (isLightMode ? 'white' : 'rgb(46, 46, 46)');
              const borderColor = isLightMode ? 'rgba(148, 163, 184, 0.22)' : 'rgba(255, 255, 255, 0.05)';
              const boxShadow = isSelected ? 'none' : (isLightMode ? '0 14px 30px -20px rgba(15, 23, 42, 0.45)' : 'none');
              const textColor = isSelected ? 'white' : (isLightMode ? '#0f172a' : '#d1d5db');
              return `
                <button 
                  class="list-item" 
                  onclick="selectBackup('${backup.path}', '${backup.folderName}')"
                  style="width: 100%; text-align: left; padding: 16px; background-color: ${bgColor}; border-radius: 12px; border: 1px solid ${borderColor}; cursor: pointer; transition: all 0.2s; box-shadow: ${boxShadow}; color: ${textColor};"
                >
                  <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="font-weight: 400; font-size: 16px;">${formatFolderName(backup.folderName)}</span>
                  </div>
                </button>
              `;
            }).join('') + `</div>`;
        } else {
          backupCount.textContent = getStyledText('ui.backupList.noBackups');
          backupList.innerHTML = `<p class="empty-state">${getStyledText('ui.backupList.noBackups')}</p>`;
        }
      } catch (error) {
        console.error('[loadBackups] Error:', error);
        showNotification('Error loading backups: ' + error.message, 'error');
      }
    }

    // Select backup
    async function selectBackup(backupPath, folderName) {
      currentBackupPath = backupPath;
      currentBackupName = folderName;
      
      // Update title and subtitle
      document.getElementById('itemsTitle').textContent = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      document.getElementById('itemsSubtitle').textContent = formatFolderName(folderName);
      
      // Reload backup list to update selection styling
      await loadBackups();
      
      // Load items based on current mode
      if (currentMode === 'lovelace') {
        await loadLovelaceFiles();
      } else if (currentMode === 'esphome') {
        await loadEsphomeFiles();
      } else if (currentMode === 'packages') {
        await loadPackagesFiles();
      } else {
        await loadBackupItems();
      }
    }

    // Load backup items
    async function loadBackupItems() {
      if (!currentBackupPath || currentMode === 'lovelace') return;
      
      const itemsList = document.getElementById('itemsList');
      itemsList.innerHTML = `<p class="loading">${getStyledText('ui.itemsList.loading', { mode: currentMode })}</p>`;
      
      try {
        const endpoint = currentMode === 'automations' 
          ? '/api/get-backup-automations' 
          : '/api/get-backup-scripts';
        
        const response = await fetch(url(endpoint), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupPath: currentBackupPath })
        });
        
        const data = await response.json();
        allItems = data.automations || data.scripts || [];
        
        if (allItems.length === 0) {
          itemsList.innerHTML = `<p class="empty-state">${getStyledText('ui.itemsList.noItems', { mode: currentMode })}</p>`;
          return;
        }
        
        // Load live items for comparison
        await loadLiveItems();
        
        // Apply search and sort
        applyFilters();
        
      } catch (error) {
        console.error('[loadBackupItems] Error:', error);
        allItems = [];
        liveItemsMap = {};
        itemStatuses = {};
        itemsList.innerHTML = `<p class="error">${applyTextStyle(`Error loading ${currentMode}: ${error.message}`, 'error')}</p>`;
      }
    }

    // Load live items
    async function loadLiveItems() {
      try {
        const itemIdentifiers = allItems.map(item => item.id || item.alias).filter(Boolean);
        
        const response = await fetch(url('/api/get-live-items'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ itemIdentifiers, mode: currentMode, liveConfigPath: haConfig.liveConfigPath })
        });
        
        const data = await response.json();
        liveItemsMap = data.liveItems || {};
        
        // Calculate statuses
        itemStatuses = {};
        allItems.forEach(item => {
          const key = item.id || item.alias || '';
          if (!key) return;
          
          const liveItem = liveItemsMap[key];
          if (!liveItem) {
            itemStatuses[key] = 'deleted';
          } else {
            const backupYaml = jsyaml.dump(item);
            const liveYaml = jsyaml.dump(liveItem);
            itemStatuses[key] = backupYaml === liveYaml ? 'unchanged' : 'changed';
          }
        });
      } catch (error) {
        console.error('[loadLiveItems] Error:', error);
        liveItemsMap = {};
        itemStatuses = {};
      }
    }

    // Apply filters (search and sort)
    function applyFilters() {
      // Ensure allItems is always an array
      if (!Array.isArray(allItems)) {
        allItems = [];
      }
      
      const searchTerm = document.getElementById('searchBox').value.toLowerCase();
      const sortOrder = document.getElementById('sortSelect').value;
      
      let filtered = allItems.filter(item => 
        (item.alias || '').toLowerCase().includes(searchTerm)
      );
      
      if (sortOrder === 'alpha-asc') {
        filtered.sort((a, b) => (a.alias || '').localeCompare(b.alias || ''));
      } else if (sortOrder === 'alpha-desc') {
        filtered.sort((a, b) => (b.alias || '').localeCompare(a.alias || ''));
      }
      
      renderItems(filtered);
    }

    // Render items
    function renderItems(items) {
      const itemsList = document.getElementById('itemsList');
      
      if (items.length === 0) {
        itemsList.innerHTML = `<p class="empty-state">${getStyledText('ui.itemsList.noMatchingItems')}</p>`;
        return;
      }
      
      itemsList.innerHTML = items.map((item, idx) => {
        const key = item.id || item.alias || '';
        const status = itemStatuses[key] || '';
        const statusBadge = status === 'changed' ? '<span class="badge badge-changed">Changed</span>' :
                           status === 'deleted' ? '<span class="badge badge-deleted">Deleted</span>' : '';
        
        return `
          <div class="list-item" data-index="${idx}">
            <div class="item-content">
              <span class="dot"></span>
              <span>${item.alias || item.id || `${currentMode} ${idx + 1}`}</span>
            </div>
            <div class="item-badges">
              ${statusBadge}
              <svg class="chevron" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
        `;
      }).join('');
      
      // Add click handlers
      document.querySelectorAll('#itemsList .list-item').forEach(item => {
        item.addEventListener('click', () => {
          const idx = parseInt(item.dataset.index);
          showDiffViewer(items[idx]);
        });
      });
    }

    // Show diff viewer
    async function showDiffViewer(item) {
      selectedItem = item;
      const key = item.id || item.alias || '';
      const liveItem = liveItemsMap[key];
      const status = itemStatuses[key];
      const backupYaml = jsyaml.dump(item);
      const liveYaml = liveItem ? jsyaml.dump(liveItem) : null;
      const noChanges = backupYaml === liveYaml;
      
      document.getElementById('diffTitle').textContent = item.alias || item.id || 'Item';
      
      const modalBody = document.getElementById('diffModalBody');
      
      // Hide close button for all states
      document.getElementById('closeDiff').style.display = 'none';
      
      if (!liveItem) {
        // Deleted state
        document.getElementById('diffSubtitle').innerHTML = `<span>${formatFolderName(currentBackupName)}</span>`;
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-deleted">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.fileDeleted')}</span>
            </div>
            <pre class="code-viewer"><code>${backupYaml}</code></pre>
          </div>`;
      } else if (noChanges) {
        // Unchanged state
        document.getElementById('diffSubtitle').textContent = '';
        document.getElementById('closeDiff').style.display = 'none';
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-unchanged">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.currentVersion')}</span>
            </div>
            <pre class="code-viewer"><code>${backupYaml}</code></pre>
          </div>`;
      } else {
        // Changed state - side by side comparison with diff highlighting
        document.getElementById('diffSubtitle').textContent = getStyledText('ui.diffViewer.compareVersions');
        const backupTimestamp = currentBackupName ? formatFolderName(currentBackupName) : '';
        const diffHtml = generateDiff(liveYaml, backupYaml, {
          leftLabel: 'Live version',
          rightLabel: 'Backup version',
          rightMeta: backupTimestamp,
          bannerText: formatFolderName(currentBackupName)
        });
        modalBody.innerHTML = `
          ${diffHtml}
        `;
      }
      
      document.getElementById('diffModal').style.display = 'flex';
    }

    // Restore item
    async function restoreItem() {
      if (!selectedItem) return;
      
      try {
        const endpoint = currentMode === 'automations' ? '/api/restore-automation' : '/api/restore-script';
        const body = currentMode === 'automations' 
          ? { automationObject: selectedItem, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, liveConfigPath: haConfig.liveConfigPath }
          : { scriptObject: selectedItem, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, liveConfigPath: haConfig.liveConfigPath };
        
        const response = await fetch(url(endpoint), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        
        if (!response.ok) {
          throw new Error('Restore failed');
        }
        
        document.getElementById('diffModal').style.display = 'none';
        
        const modeLabel = currentMode === 'automations' ? 'Automation' : 'Script';

        // Reload Home Assistant if configured
        if (haConfig && haConfig.haAuthConfigured) {
          const service = currentMode === 'automations' ? 'automation.reload' : 'script.reload';
          try {
            const reloadResponse = await fetch(url('/api/reload-home-assistant'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ service })
            });
            if (!reloadResponse.ok) {
              throw new Error('Reload request failed');
            }
            showNotification(getStyledText('notifications.automationsReloaded', { mode: modeLabel }) || `${modeLabel} reloaded successfully in Home Assistant!`);
          } catch (reloadError) {
            console.error('[restoreItem] Reload error:', reloadError);
            showNotification(getStyledText('notifications.itemRestoredManual', { mode: modeLabel }) || `${modeLabel} restored! Reload manually in Home Assistant.`, 'info');
          }
        } else {
          showNotification(getStyledText('notifications.itemRestoredManual', { mode: modeLabel }) || `${modeLabel} restored! Manual reload required.`, 'info');
        }
        
        // Reload items
        await loadBackupItems();
      } catch (error) {
        console.error('[restoreItem] Error:', error);
        showNotification(getStyledText('notifications.errorGeneric', { error: error.message }) || ('Error restoring item: ' + error.message), 'error');
      }
    }

    // Lovelace files state
    let lovelaceFiles = [];
    let lovelaceFileStatuses = {};
    let selectedLovelaceFile = null;
    let lovelaceBackupContent = '';
    let lovelaceLiveContent = null;

    // ESPHome files state
    let esphomeFiles = [];
    let esphomeFileStatuses = {};
    let selectedEsphomeFile = null;
    let esphomeBackupContent = '';
    let esphomeLiveContent = null;

    // Packages files state
    let packagesFiles = [];
    let packagesFileStatuses = {};
    let selectedPackagesFile = null;
    let packagesBackupContent = '';
    let packagesLiveContent = null;

    // Load Lovelace files
    async function loadLovelaceFiles() {
      if (!currentBackupPath) return;
      const itemsList = document.getElementById('itemsList');
      itemsList.innerHTML = `<p class="loading">${getStyledText('ui.lovelace.loading')}</p>`;
      try {
        const response = await fetch(url('/api/get-backup-lovelace'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupPath: currentBackupPath })
        });
        const data = await response.json();
        const fileNames = data.lovelaceFiles || [];
        lovelaceFiles = [];
        lovelaceFileStatuses = {};
        
        for (const fileName of fileNames) {
          let status = 'unchanged';
          try {
            const liveParams = new URLSearchParams({ fileName });
            if (haConfig?.liveConfigPath) {
              liveParams.append('liveConfigPath', haConfig.liveConfigPath);
            }
            const liveResp = await fetch(url(`/api/get-live-lovelace-file?${liveParams.toString()}`));
            if (liveResp.ok) {
              const liveData = await liveResp.text();
              const backupResp = await fetch(url('/api/get-backup-lovelace-file'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backupPath: currentBackupPath, fileName })
              });
              const backupData = await backupResp.text();
              if (backupData !== liveData) {
                status = 'changed';
              }
            } else {
              status = 'deleted';
            }
          } catch (err) {
            console.error('Error checking Lovelace file status:', err);
          }
          lovelaceFiles.push({ name: fileName, status });
          lovelaceFileStatuses[fileName] = status;
        }
        renderLovelaceFiles(lovelaceFiles);
      } catch (error) {
        console.error('[loadLovelaceFiles] Error:', error);
        itemsList.innerHTML = `<p class="error">${applyTextStyle('Error loading Lovelace files: ' + error.message, 'error')}</p>`;
      }
    }

    // Render Lovelace files
    function renderLovelaceFiles(files) {
      const itemsList = document.getElementById('itemsList');
      if (files.length === 0) {
        itemsList.innerHTML = `<p class="empty-state">${getStyledText('ui.lovelace.noFiles')}</p>`;
        return;
      }
      itemsList.innerHTML = files.map((file, idx) => {
        const status = lovelaceFileStatuses[file.name] || '';
        const statusBadge = status === 'changed' ? '<span class="badge badge-changed">Changed</span>' :
                           status === 'deleted' ? '<span class="badge badge-deleted">Deleted</span>' : '';
        return `
          <div class="list-item" data-index="${idx}">
            <div class="item-content">
              <span class="dot"></span>
              <span>${file.name}</span>
            </div>
            <div class="item-badges">
              ${statusBadge}
              <svg class="chevron" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
        `;
      }).join('');
      document.querySelectorAll('#itemsList .list-item').forEach((item, idx) => {
        item.addEventListener('click', async () => {
          selectedLovelaceFile = lovelaceFiles[idx];
          lovelaceBackupContent = '';
          lovelaceLiveContent = null;
          try {
            const backupResp = await fetch(url('/api/get-backup-lovelace-file'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ backupPath: currentBackupPath, fileName: selectedLovelaceFile.name })
            });
            lovelaceBackupContent = await backupResp.text();
            if (selectedLovelaceFile.status !== 'deleted') {
              const liveParams = new URLSearchParams({ fileName: selectedLovelaceFile.name });
              if (haConfig?.liveConfigPath) {
                liveParams.append('liveConfigPath', haConfig.liveConfigPath);
              }
              const liveResp = await fetch(url(`/api/get-live-lovelace-file?${liveParams.toString()}`));
              if (liveResp.ok) {
                lovelaceLiveContent = await liveResp.text();
              }
            }
            showLovelaceDiffModal();
          } catch (error) {
            showNotification('Error loading file: ' + error.message, 'error');
          }
        });
      });
    }

    // Show Lovelace diff modal
    function showLovelaceDiffModal() {
      const modal = document.getElementById('diffModal');
      const status = lovelaceFileStatuses[selectedLovelaceFile.name];
      const noChanges = lovelaceBackupContent === lovelaceLiveContent;
      
      document.getElementById('diffTitle').textContent = selectedLovelaceFile.name;
      
      const modalBody = document.getElementById('diffModalBody');
      
      // Hide close button for all states
      document.getElementById('closeDiff').style.display = 'none';
      
      if (!lovelaceLiveContent) {
        // Deleted state
        document.getElementById('diffSubtitle').innerHTML = `<span>${formatFolderName(currentBackupName)}</span>`;
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-deleted">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.fileDeleted')}</span>
            </div>
            <pre class="code-viewer"><code>${lovelaceBackupContent}</code></pre>
          </div>
        `;
      } else if (noChanges) {
        // Unchanged state
        document.getElementById('diffSubtitle').textContent = getStyledText('ui.diffViewer.noChanges');
        document.getElementById('closeDiff').style.display = 'none';
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-unchanged">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.currentVersion')}</span>
            </div>
            <pre class="code-viewer"><code>${lovelaceBackupContent}</code></pre>
          </div>
        `;
      } else {
        // Changed state - side by side comparison with diff highlighting
        document.getElementById('diffSubtitle').textContent = getStyledText('ui.diffViewer.compareVersions');
        const backupTimestamp = currentBackupName ? formatFolderName(currentBackupName) : '';
        const diffHtml = generateDiff(lovelaceLiveContent, lovelaceBackupContent, {
          leftLabel: 'Live version',
          rightLabel: 'Backup version',
          rightMeta: backupTimestamp,
          bannerText: formatFolderName(currentBackupName)
        });
        modalBody.innerHTML = `
          ${diffHtml}
        `;
      }
      
      modal.style.display = 'flex';
    }

    // Restore Lovelace file
    async function restoreLovelaceFile() {
      if (!selectedLovelaceFile) return;
      
      try {
        const response = await fetch(url('/api/restore-lovelace-file'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            fileName: selectedLovelaceFile.name,
            content: lovelaceBackupContent,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            liveConfigPath: haConfig.liveConfigPath
          })
        });
        
        if (!response.ok) {
          throw new Error('Restore failed');
        }
        
        document.getElementById('diffModal').style.display = 'none';
        
        // Reload Home Assistant if configured
        if (haConfig && haConfig.haAuthConfigured) {
          const service = 'lovelace.reload';
          try {
            const reloadResponse = await fetch(url('/api/reload-home-assistant'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ service })
            });
            if (!reloadResponse.ok) {
              throw new Error('Reload request failed');
            }
            showRestartNotification(getStyledText('notifications.lovelaceRestored') || 'Lovelace successfully restored! Restart Home Assistant to see changes.', haConfig);
          } catch (reloadError) {
            console.error('[restoreLovelaceFile] Reload error:', reloadError);
            showRestartNotification(getStyledText('notifications.lovelaceRestored') || 'Lovelace successfully restored! Restart Home Assistant to see changes.', haConfig);
          }
        } else {
          showRestartNotification(getStyledText('notifications.lovelaceRestored') || 'Lovelace successfully restored! Restart Home Assistant to see changes.', haConfig);
        }
        
        // Reload items
        await loadLovelaceFiles();
      } catch (error) {
        console.error('[restoreLovelaceFile] Error:', error);
        showNotification(getStyledText('notifications.errorGeneric', { error: error.message }) || ('Error restoring file: ' + error.message), 'error');
      }
    }

    // Load ESPHome files
    async function loadEsphomeFiles() {
      if (!currentBackupPath) return;
      const itemsList = document.getElementById('itemsList');
      if (!esphomeFeatureEnabled) {
        itemsList.innerHTML = `<p class="empty-state">${getEsphomeDisabledMessage()}</p>`;
        return;
      }
      itemsList.innerHTML = `<p class="loading">${getStyledText('ui.esphome.loading')}</p>`;
      try {
        const response = await fetch(url('/api/get-backup-esphome'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupPath: currentBackupPath })
        });
        if (response.status === 404) {
          itemsList.innerHTML = `<p class="empty-state">${getEsphomeDisabledMessage()}</p>`;
          return;
        }
        const data = await response.json();
        const fileNames = data.esphomeFiles || [];
        esphomeFiles = [];
        esphomeFileStatuses = {};
        
        for (const fileName of fileNames) {
          let status = 'unchanged';
          try {
            const liveResp = await fetch(url('/api/get-live-esphome-file'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ fileName, liveConfigPath: haConfig.liveConfigPath })
            });
            if (liveResp.ok) {
              const liveData = await liveResp.json();
              const backupResp = await fetch(url('/api/get-backup-esphome-file'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backupPath: currentBackupPath, fileName })
              });
              const backupData = await backupResp.json();
              if (backupData.content !== liveData.content) {
                status = 'changed';
              }
            } else {
              status = 'deleted';
            }
          } catch (err) {
            console.error('Error checking ESPHome file status:', err);
          }
          esphomeFiles.push({ name: fileName, status });
          esphomeFileStatuses[fileName] = status;
        }
        renderEsphomeFiles(esphomeFiles);
      } catch (error) {
        console.error('[loadEsphomeFiles] Error:', error);
        itemsList.innerHTML = `<p class="${esphomeFeatureEnabled ? 'error' : 'empty-state'}">${esphomeFeatureEnabled ? applyTextStyle('Error loading ESPHome files: ' + error.message, 'error') : getEsphomeDisabledMessage()}</p>`;
      }
    }

    // Render ESPHome files
    function renderEsphomeFiles(files) {
      const itemsList = document.getElementById('itemsList');
      if (files.length === 0) {
        itemsList.innerHTML = `<p class="empty-state">${getStyledText('ui.esphome.noFiles')}</p>`;
        return;
      }
      itemsList.innerHTML = files.map((file, idx) => {
        const status = esphomeFileStatuses[file.name] || '';
        const statusBadge = status === 'changed' ? '<span class="badge badge-changed">Changed</span>' :
                           status === 'deleted' ? '<span class="badge badge-deleted">Deleted</span>' : '';
        return `
          <div class="list-item" data-index="${idx}">
            <div class="item-content">
              <span class="dot"></span>
              <span>${file.name}</span>
            </div>
            <div class="item-badges">
              ${statusBadge}
              <svg class="chevron" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
        `;
      }).join('');
      document.querySelectorAll('#itemsList .list-item').forEach((item, idx) => {
        item.addEventListener('click', async () => {
          selectedEsphomeFile = esphomeFiles[idx];
          esphomeBackupContent = '';
          esphomeLiveContent = null;
          try {
            const backupResp = await fetch(url('/api/get-backup-esphome-file'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ backupPath: currentBackupPath, fileName: selectedEsphomeFile.name })
            });
            const backupData = await backupResp.json();
            esphomeBackupContent = backupData.content;
            if (selectedEsphomeFile.status !== 'deleted') {
              const liveResp = await fetch(url('/api/get-live-esphome-file'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: selectedEsphomeFile.name, liveConfigPath: haConfig.liveConfigPath })
              });
              if (liveResp.ok) {
                const liveData = await liveResp.json();
                esphomeLiveContent = liveData.content;
              }
            }
            showEsphomeDiffModal();
          } catch (error) {
            showNotification('Error loading file: ' + error.message, 'error');
          }
        });
      });
    }

    // Show ESPHome diff modal
    function showEsphomeDiffModal() {
      const modal = document.getElementById('diffModal');
      const status = esphomeFileStatuses[selectedEsphomeFile.name];
      const noChanges = esphomeBackupContent === esphomeLiveContent;
      
      document.getElementById('diffTitle').textContent = selectedEsphomeFile.name;
      
      const modalBody = document.getElementById('diffModalBody');
      
      // Hide close button for all states
      document.getElementById('closeDiff').style.display = 'none';
      
      if (!esphomeLiveContent) {
        // Deleted state
        document.getElementById('diffSubtitle').innerHTML = `<span>${formatFolderName(currentBackupName)}</span>`;
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-deleted">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.fileDeleted')}</span>
            </div>
            <pre class="code-viewer"><code>${esphomeBackupContent}</code></pre>
          </div>
        `;
      } else if (noChanges) {
        // Unchanged state
        document.getElementById('diffSubtitle').textContent = getStyledText('ui.diffViewer.noChanges');
        document.getElementById('closeDiff').style.display = 'none';
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-unchanged">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.currentVersion')}</span>
            </div>
            <pre class="code-viewer"><code>${esphomeBackupContent}</code></pre>
          </div>
        `;
      } else {
        // Changed state - side by side comparison with diff highlighting
        document.getElementById('diffSubtitle').textContent = 'Compare backup with current live version.';
        const backupTimestamp = currentBackupName ? formatFolderName(currentBackupName) : '';
        const diffHtml = generateDiff(esphomeLiveContent, esphomeBackupContent, {
          leftLabel: 'Live version',
          rightLabel: 'Backup version',
          rightMeta: backupTimestamp,
          bannerText: formatFolderName(currentBackupName)
        });
        modalBody.innerHTML = `
          ${diffHtml}
        `;
      }
      
      modal.style.display = 'flex';
    }

    // Restore ESPHome file
    async function restoreEsphomeFile() {
      if (!selectedEsphomeFile) return;
      if (!esphomeFeatureEnabled) return;
      try {
        const response = await fetch(url('/api/restore-esphome-file'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fileName: selectedEsphomeFile.name, content: esphomeBackupContent, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, liveConfigPath: haConfig.liveConfigPath })
        });
        if (!response.ok) throw new Error('Restore failed');
        const data = await response.json(); // Get the response data
        document.getElementById('diffModal').style.display = 'none';

        showNotification('ESPHome file restored!', 'success');
        await loadEsphomeFiles();
      } catch (error) {
        console.error('[restoreEsphomeFile] Error:', error);
        showNotification(getStyledText('notifications.errorGeneric', { error: error.message }) || ('Error restoring file: ' + error.message), 'error');
      }
    }

    // Load Packages files
    async function loadPackagesFiles() {
      if (!currentBackupPath) return;
      const itemsList = document.getElementById('itemsList');
      if (!packagesFeatureEnabled) {
        itemsList.innerHTML = `<p class="empty-state">${getPackagesDisabledMessage()}</p>`;
        return;
      }
      itemsList.innerHTML = `<p class="loading">${getStyledText('ui.packages.loading')}</p>`;
      try {
        const response = await fetch(url('/api/get-backup-packages'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ backupPath: currentBackupPath })
        });
        if (response.status === 404) {
          itemsList.innerHTML = `<p class="empty-state">${getPackagesDisabledMessage()}</p>`;
          return;
        }
        const data = await response.json();
        const fileNames = data.packagesFiles || [];
        packagesFiles = [];
        packagesFileStatuses = {};
        
        for (const fileName of fileNames) {
          let status = 'unchanged';
          try {
            const liveResp = await fetch(url('/api/get-live-packages-file'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ fileName, liveConfigPath: haConfig.liveConfigPath })
            });
            if (liveResp.ok) {
              const liveData = await liveResp.json();
              const backupResp = await fetch(url('/api/get-backup-packages-file'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backupPath: currentBackupPath, fileName })
              });
              const backupData = await backupResp.json();
              if (backupData.content !== liveData.content) {
                status = 'changed';
              }
            } else {
              status = 'deleted';
            }
          } catch (err) {
            console.error('Error checking Packages file status:', err);
          }
          packagesFiles.push({ name: fileName, status });
          packagesFileStatuses[fileName] = status;
        }
        renderPackagesFiles(packagesFiles);
      } catch (error) {
        console.error('[loadPackagesFiles] Error:', error);
        itemsList.innerHTML = `<p class="${packagesFeatureEnabled ? 'error' : 'empty-state'}">${packagesFeatureEnabled ? applyTextStyle('Error loading Packages files: ' + error.message, 'error') : getPackagesDisabledMessage()}</p>`;
      }
    }

    // Render Packages files
    function renderPackagesFiles(files) {
      const itemsList = document.getElementById('itemsList');
      if (files.length === 0) {
        itemsList.innerHTML = `<p class="empty-state">${getStyledText('ui.packages.noFiles')}</p>`;
        return;
      }
      itemsList.innerHTML = files.map((file, idx) => {
        const status = packagesFileStatuses[file.name] || '';
        const statusBadge = status === 'changed' ? '<span class="badge badge-changed">Changed</span>' :
                           status === 'deleted' ? '<span class="badge badge-deleted">Deleted</span>' : '';
        return `
          <div class="list-item" data-index="${idx}">
            <div class="item-content">
              <span class="dot"></span>
              <span>${file.name}</span>
            </div>
            <div class="item-badges">
              ${statusBadge}
              <svg class="chevron" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
        `;
      }).join('');
      document.querySelectorAll('#itemsList .list-item').forEach((item, idx) => {
        item.addEventListener('click', async () => {
          selectedPackagesFile = packagesFiles[idx];
          packagesBackupContent = '';
          packagesLiveContent = null;
          try {
            const backupResp = await fetch(url('/api/get-backup-packages-file'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ backupPath: currentBackupPath, fileName: selectedPackagesFile.name })
            });
            const backupData = await backupResp.json();
            packagesBackupContent = backupData.content;
            if (selectedPackagesFile.status !== 'deleted') {
              const liveResp = await fetch(url('/api/get-live-packages-file'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: selectedPackagesFile.name, liveConfigPath: haConfig.liveConfigPath })
              });
              if (liveResp.ok) {
                const liveData = await liveResp.json();
                packagesLiveContent = liveData.content;
              }
            }
            showPackagesDiffModal();
          } catch (error) {
            showNotification('Error loading file: ' + error.message, 'error');
          }
        });
      });
    }

    // Show Packages diff modal
    function showPackagesDiffModal() {
      const modal = document.getElementById('diffModal');
      const status = packagesFileStatuses[selectedPackagesFile.name];
      const noChanges = packagesBackupContent === packagesLiveContent;
      
      document.getElementById('diffTitle').textContent = selectedPackagesFile.name;
      
      const modalBody = document.getElementById('diffModalBody');
      
      // Hide close button for all states
      document.getElementById('closeDiff').style.display = 'none';
      
      if (!packagesLiveContent) {
        // Deleted state
        document.getElementById('diffSubtitle').innerHTML = `<span>${formatFolderName(currentBackupName)}</span>`;
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-deleted">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.fileDeleted')}</span>
            </div>
            <pre class="code-viewer"><code>${packagesBackupContent}</code></pre>
          </div>
        `;
      } else if (noChanges) {
        // Unchanged state
        document.getElementById('diffSubtitle').textContent = getStyledText('ui.diffViewer.noChanges');
        document.getElementById('closeDiff').style.display = 'none';
        modalBody.innerHTML = `
          <div class="diff-state-block">
            <div class="diff-state-banner diff-state-banner-unchanged">
              <span class="diff-state-label">${getStyledText('ui.diffViewer.currentVersion')}</span>
            </div>
            <pre class="code-viewer"><code>${packagesBackupContent}</code></pre>
          </div>
        `;
      } else {
        // Changed state - side by side comparison with diff highlighting
        document.getElementById('diffSubtitle').textContent = 'Compare backup with current live version.';
        const backupTimestamp = currentBackupName ? formatFolderName(currentBackupName) : '';
        const diffHtml = generateDiff(packagesLiveContent, packagesBackupContent, {
          leftLabel: 'Live version',
          rightLabel: 'Backup version',
          rightMeta: backupTimestamp,
          bannerText: formatFolderName(currentBackupName)
        });
        modalBody.innerHTML = `
          ${diffHtml}
        `;
      }
      
      modal.style.display = 'flex';
    }

    // Restore Packages file
    async function restorePackagesFile() {
      if (!selectedPackagesFile) return;
      if (!packagesFeatureEnabled) return;
      try {
        const response = await fetch(url('/api/restore-packages-file'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fileName: selectedPackagesFile.name, content: packagesBackupContent, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, liveConfigPath: haConfig.liveConfigPath })
        });
        if (!response.ok) throw new Error('Restore failed');
        const data = await response.json(); // Get the response data
        document.getElementById('diffModal').style.display = 'none';

        const canReload = data.needsRestart && haConfig && haConfig.haAuthConfigured;
        if (canReload) {
          try {
            const reloadResponse = await fetch(url('/api/reload-home-assistant'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ service: 'homeassistant.reload_all' })
            });
            if (!reloadResponse.ok) {
              throw new Error('Reload request failed');
            }
            showNotification(getStyledText('notifications.packagesReloaded') || 'Packages file restored and Home Assistant reloaded!', 'success');
          } catch (reloadError) {
            console.error('[restorePackagesFile] Reload error:', reloadError);
            showNotification(getStyledText('notifications.packagesManualReload') || 'Packages file restored! Reload Home Assistant manually.', 'info');
          }
        } else if (data.needsRestart) {
          showNotification(getStyledText('notifications.packagesManualReload') || 'Packages file restored! Reload Home Assistant manually.', 'info');
        } else {
          showNotification(getStyledText('notifications.packagesRestored') || 'Packages file restored!', 'success');
        }
        await loadPackagesFiles();
      } catch (error) {
        console.error('[restorePackagesFile] Error:', error);
        showNotification(getStyledText('notifications.errorGeneric', { error: error.message }) || ('Error restoring file: ' + error.message), 'error');
      }
    }

    // Update restore button for Lovelace
    document.getElementById('restoreBtn').addEventListener('click', () => {
      if (currentMode === 'lovelace') {
        restoreLovelaceFile();
      } else if (currentMode === 'esphome' && esphomeFeatureEnabled) {
        restoreEsphomeFile();
      } else if (currentMode === 'packages' && packagesFeatureEnabled) {
        restorePackagesFile();
      } else {
        restoreItem();
      }
    });

    // Main tab switching (Files vs Backups)
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabType = tab.dataset.tab;

        if (tabType === 'files') {
          // Switch to Files mode
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById('subtabs').classList.add('hidden');
          document.getElementById('standardContent').style.display = 'none';
          document.getElementById('filesContent').style.display = 'grid';
          currentMode = 'files';
          loadFileTree();
        } else if (tabType === 'backups') {
          // Switch to Backups mode (show subtabs)
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById('subtabs').classList.remove('hidden');
          document.getElementById('standardContent').style.display = 'grid';
          document.getElementById('filesContent').style.display = 'none';

          // Keep the currently selected subtab active (or default to automations)
          const activeSubtab = document.querySelector('.subtab.active');
          if (activeSubtab) {
            currentMode = activeSubtab.dataset.tab;
          } else {
            currentMode = 'automations';
            document.getElementById('automationsTab').classList.add('active');
          }

          // Load content for the active subtab
          loadSubtabContent(currentMode);
        }
      });
    });

    // Subtab switching
    document.querySelectorAll('.subtab').forEach(subtab => {
      subtab.addEventListener('click', () => {
        const newMode = subtab.dataset.tab;
        if (newMode === currentMode) return;

        if (newMode === 'esphome' && !esphomeFeatureEnabled) {
          showNotification(getEsphomeDisabledMessage(), 'info');
          return;
        }

        if (newMode === 'packages' && !packagesFeatureEnabled) {
          showNotification(getPackagesDisabledMessage(), 'info');
          return;
        }

        document.querySelectorAll('.subtab').forEach(t => t.classList.remove('active'));
        subtab.classList.add('active');
        currentMode = newMode;

        loadSubtabContent(currentMode);
      });
    });

    // Helper function to load subtab content
    function loadSubtabContent(mode) {
      // Reset items state
      allItems = [];
      liveItemsMap = {};
      itemStatuses = {};

      // Update search placeholder
      updatePlaceholders();

      // Update title
      document.getElementById('itemsTitle').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);

      if (currentBackupPath && mode !== 'lovelace' && mode !== 'esphome' && mode !== 'packages') {
        loadBackupItems();
      } else if (mode === 'lovelace' && currentBackupPath) {
        loadLovelaceFiles();
      } else if (mode === 'esphome' && currentBackupPath) {
        loadEsphomeFiles();
      } else if (mode === 'packages' && currentBackupPath) {
        loadPackagesFiles();
      } else {
        // Show empty state based on mode
        const modeLabel = mode === 'lovelace'
          ? 'lovelace files'
          : mode === 'esphome'
            ? 'ESPHome files'
            : mode;
        const emptyMessage = 'Select a backup to view ' + modeLabel;
        document.getElementById('itemsList').innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;"><div style="width: 64px; height: 64px; background-color: rgba(255, 255, 255, 0.05); border-radius: 16px; display: flex; align-items: center; justify-content: center; margin-bottom: 16px;"><svg style="width: 32px; height: 32px; color: #6b7280;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0112.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg></div><p style="color: #9ca3af;">${emptyMessage}</p></div>`;
      }
    }

    // Initialize tab state immediately (script is at bottom of body, DOM is ready)
    // The HTML defaults to "Backups" tab being active, but we want Files to be the default
    (() => {
      const filesTab = document.getElementById('filesTab');
      const backupsTab = document.getElementById('backupsTab');
      const subtabs = document.getElementById('subtabs');
      const filesContent = document.getElementById('filesContent');
      const standardContent = document.getElementById('standardContent');

      // Check which tab is active in HTML
      if (filesTab && filesTab.classList.contains('active')) {
        // Files tab is active - hide subtabs, show files content
        subtabs.classList.add('hidden');
        standardContent.style.display = 'none';
        filesContent.style.display = 'grid';
        currentMode = 'files';
        loadFileTree();
      } else if (backupsTab && backupsTab.classList.contains('active')) {
        // Backups tab is active - show subtabs, hide files content
        subtabs.classList.remove('hidden');
        standardContent.style.display = 'grid';
        filesContent.style.display = 'none';
        // Keep the currently selected subtab active (or default to automations)
        const activeSubtab = document.querySelector('.subtab.active');
        currentMode = activeSubtab ? activeSubtab.dataset.tab : 'automations';
      }
    })();

    document.getElementById('searchBox').addEventListener('input', applyFilters);
    document.getElementById('sortSelect').addEventListener('change', applyFilters);

    // Path validation
    async function validateLivePath(path) {
      const errorEl = document.getElementById('liveConfigPathError');
      if (!path) {
        errorEl.textContent = '';
        return;
      }
      try {
        const response = await fetch(url('/api/validate-path'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path, type: 'live' })
        });
        const data = await response.json();
        if (data.errorCode) {
          errorEl.textContent = getSettingsMessageFromCode(data.errorCode, { path: data.path || path });
        } else if (data.error) {
          errorEl.textContent = applyTextStyle(data.error, 'error');
        } else {
          errorEl.textContent = '';
        }
      } catch (error) {
        errorEl.textContent = getSettingsMessageFromCode('unknown', { path });
      }
    }
    
    async function validateBackupPath(path) {
      const errorEl = document.getElementById('backupPathError');
      if (!path) {
        errorEl.textContent = '';
        return;
      }
      try {
        const response = await fetch(url('/api/validate-path'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path, type: 'backup' })
        });
        const data = await response.json();
        if (data.errorCode) {
          errorEl.textContent = getSettingsMessageFromCode(data.errorCode, { path: data.path || path });
        } else if (data.error) {
          errorEl.textContent = applyTextStyle(data.error, 'error');
        } else {
          errorEl.textContent = '';
        }
      } catch (error) {
        errorEl.textContent = getSettingsMessageFromCode('unknown', { path });
      }
    }

    // Settings modal
    document.getElementById('settingsBtn').addEventListener('click', () => {
      if (haConfig) {
        const isDocker = haConfig.mode === 'docker';
        const allowManual = isDocker && !haConfig.haAuthConfigured;
        const managedBySupervisor = haConfig.haAuthMode === 'supervisor';

        const haConnectionFields = document.getElementById('haConnectionFields');
        const haUrlField = document.getElementById('haUrl');
        const haTokenField = document.getElementById('haToken');

        // Toggle visibility of HA connection fields based on supervisor mode
        if (managedBySupervisor) {
          haConnectionFields.classList.add('managed-by-supervisor');
        } else {
          haConnectionFields.classList.remove('managed-by-supervisor');
        }

        if (allowManual) {
          haUrlField.readOnly = false;
          haUrlField.placeholder = 'http://your-ha-instance:8123';
          haUrlField.style.color = '#d1d5db';
          haUrlField.style.backgroundColor = '#2d2d2d';

          haTokenField.readOnly = false;
          haTokenField.placeholder = 'Your long-lived access token';
          haTokenField.style.color = '#d1d5db';
          haTokenField.style.backgroundColor = '#2d2d2d';
        } else {
          haUrlField.readOnly = true;
          haUrlField.placeholder = managedBySupervisor
            ? 'Automatically managed by Home Assistant'
            : 'Configured via saved credentials';
          haUrlField.style.color = '#9ca3af';
          haUrlField.style.backgroundColor = '#2d2d2d';

          haTokenField.readOnly = true;
          haTokenField.placeholder = managedBySupervisor
            ? 'Automatically managed by Home Assistant'
            : 'Configured via saved credentials';
          haTokenField.style.color = '#9ca3af';
          haTokenField.style.backgroundColor = '#2d2d2d';
        }

        haUrlField.value = allowManual ? (haConfig.haUrl || '') : '';
        haTokenField.value = '';
        currentTextStyle = haConfig?.textStyle || 'default';

        document.getElementById('liveConfigPath').value = haConfig.liveConfigPath || '/config';
        document.getElementById('backupFolderPath').value = haConfig.backupFolderPath || '/media/backups/yaml';

        // Load Git mode settings
        console.log('[Settings UI] Loading Git settings from haConfig:', {
          backupMode: haConfig.backupMode,
          fileWatchingEnabled: haConfig.fileWatchingEnabled,
          fileWatchingDebounce: haConfig.fileWatchingDebounce
        });
        document.getElementById('backupMode').value = haConfig.backupMode || 'folder';
        document.getElementById('fileWatchingEnabled').checked = haConfig.fileWatchingEnabled || false;
        document.getElementById('fileWatchingDebounce').value = haConfig.fileWatchingDebounce || 60;
        console.log('[Settings UI] After setting, select value is:', document.getElementById('backupMode').value);

        // Show/hide Git settings based on backup mode
        const gitModeSettings = document.getElementById('gitModeSettings');
        const fileWatchingOptions = document.getElementById('fileWatchingOptions');
        if (haConfig.backupMode === 'git') {
          gitModeSettings.style.display = 'block';
        } else {
          gitModeSettings.style.display = 'none';
        }
        if (haConfig.fileWatchingEnabled) {
          fileWatchingOptions.style.display = 'block';
        } else {
          fileWatchingOptions.style.display = 'none';
        }
      }
      updateUIText(); // Update text for current style
      loadScheduleSettings();
      
      // Validate paths on open
      const livePath = document.getElementById('liveConfigPath').value;
      const backupPath = document.getElementById('backupFolderPath').value;
      validateLivePath(livePath);
      validateBackupPath(backupPath);
      
      document.getElementById('settingsModal').style.display = 'flex';
    });
    
    // Add blur event listeners for path validation
    document.getElementById('liveConfigPath').addEventListener('blur', (e) => {
      validateLivePath(e.target.value);
    });
    
    document.getElementById('backupFolderPath').addEventListener('blur', (e) => {
      validateBackupPath(e.target.value);
    });

    document.getElementById('cancelSettings').addEventListener('click', () => {
      // Clear status messages when closing settings
      document.getElementById('connectionStatus').textContent = '';
      document.getElementById('backupStatus').textContent = '';
      document.getElementById('settingsModal').style.display = 'none';
    });

    // Click outside to close settings modal
    document.getElementById('settingsModal').addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) {
        // Clear status messages when closing settings
        document.getElementById('connectionStatus').textContent = '';
        document.getElementById('backupStatus').textContent = '';
        document.getElementById('settingsModal').style.display = 'none';
      }
    });

    // Git mode event listeners
    document.getElementById('backupMode').addEventListener('change', (e) => {
      const gitModeSettings = document.getElementById('gitModeSettings');
      if (e.target.value === 'git') {
        gitModeSettings.style.display = 'block';
      } else {
        gitModeSettings.style.display = 'none';
      }
    });

    document.getElementById('fileWatchingEnabled').addEventListener('change', (e) => {
      const fileWatchingOptions = document.getElementById('fileWatchingOptions');
      if (e.target.checked) {
        fileWatchingOptions.style.display = 'block';
      } else {
        fileWatchingOptions.style.display = 'none';
      }
    });

    // Settings form
    document.getElementById('settingsForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const liveConfigPath = document.getElementById('liveConfigPath').value;
      const backupFolderPath = document.getElementById('backupFolderPath').value;
      const textStyle = currentTextStyle || 'default';
      
      const isDocker = haConfig && haConfig.mode === 'docker';
      const isAddon = haConfig && haConfig.mode === 'addon';
      const shouldPersistPaths = haConfig && (isDocker || isAddon);
      const allowManual = haConfig && !haConfig.haAuthConfigured;
      
      // Save HA credentials if in Docker mode without env vars
      if (isDocker && allowManual) {
        const homeAssistantUrl = document.getElementById('haUrl').value.trim();
        const longLivedAccessToken = document.getElementById('haToken').value.trim();
        
        if (homeAssistantUrl && longLivedAccessToken) {
          try {
            await fetch(url('/api/docker-ha-credentials'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                homeAssistantUrl,
                longLivedAccessToken
              })
            });
          } catch (error) {
            console.error('[save-ha-credentials] Error:', error);
          }
        }
      }
      
      // Save Docker app settings if in Docker mode
      if (shouldPersistPaths) {
        // Get Git mode settings
        const backupMode = document.getElementById('backupMode').value;
        const fileWatchingEnabled = document.getElementById('fileWatchingEnabled').checked;
        const fileWatchingDebounce = parseInt(document.getElementById('fileWatchingDebounce').value) || 60;

        console.log('[save-settings] Persisting settings:', { mode: haConfig?.mode, liveConfigPath, backupFolderPath, backupMode, fileWatchingEnabled });
        try {
          const response = await fetch(url('/api/app-settings'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              liveConfigPath,
              backupFolderPath,
              textStyle,
              theme: currentTheme,
              esphomeEnabled: esphomeFeatureEnabled,
              packagesEnabled: packagesFeatureEnabled,
              // Git-based backup settings
              backupMode,
              fileWatchingEnabled,
              fileWatchingDebounce,
              watchedPaths: ['config', 'lovelace', 'esphome', 'packages']
            })
          });
          console.log('[save-settings] Save response ok:', response.ok, 'status:', response.status);
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[save-settings] Save failed:', errorText);
          }
        } catch (error) {
          console.error('[save-docker-settings] Error:', error);
        }
      }
      
      // Update haConfig with paths only
      if (haConfig) {
        haConfig.liveConfigPath = liveConfigPath;
        haConfig.backupFolderPath = backupFolderPath;
        haConfig.textStyle = textStyle;
        haConfig.esphomeEnabled = esphomeFeatureEnabled;
        currentTextStyle = textStyle;
        updateEsphomeVisibility();

        // Update currentBackupPath if we're in a backup folder view
        if (currentBackupPath && currentBackupPath.startsWith(haConfig.backupFolderPath)) {
          // If we were in a backup folder, update the path to maintain the same relative location
          const relativePath = currentBackupPath.substring(haConfig.backupFolderPath.length);
          currentBackupPath = backupFolderPath + (relativePath.startsWith('/') ? '' : '/') + relativePath;
        } else if (currentBackupPath) {
          // If we were not in a backup folder, just update the base path
          currentBackupPath = backupFolderPath;
        }
      }
      
      // Save schedule
      const scheduleEnabled = document.getElementById('scheduleEnabled').checked;
      const scheduleFrequency = document.getElementById('scheduleFrequency').value;
      const scheduleTime = document.getElementById('scheduleTime').value;
      const scheduleDay = document.getElementById('scheduleDay').value;
      const maxBackupsEnabled = document.getElementById('maxBackupsEnabled').checked;
      const maxBackupsCount = parseInt(document.getElementById('maxBackupsCount').value) || 10;
      
      const cronExpression = scheduleToCron(scheduleFrequency, scheduleTime, scheduleDay);
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetch(url('/api/schedule-backup'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: 'default-backup-job',
          enabled: scheduleEnabled,
          cronExpression,
          timezone,
          liveConfigPath,
          backupFolderPath,
          maxBackupsEnabled,
          maxBackupsCount,
          scheduleDay
        })
      });
      
      // Close the modal
      document.getElementById('settingsModal').style.display = 'none';
      
      // If we're in a backup folder view, reload the items to show the new path
      if (currentBackupPath) {
        if (currentMode === 'lovelace') {
          await loadLovelaceFiles();
        } else if (currentMode === 'esphome') {
          await loadEsphomeFiles();
        } else {
          await loadBackupItems();
        }
        
      } else {
        // If not in a specific backup folder, just reload the page
        window.location.reload();
      }
    });

    // Test connection
    document.getElementById('testConnection').addEventListener('click', async () => {
      const status = document.getElementById('connectionStatus');
      
      status.textContent = '';
      status.className = 'settings-inline-text';
      
      try {
        const haUrl = document.getElementById('haUrl').value.trim();
        const haToken = document.getElementById('haToken').value.trim();
        const payload = (haUrl && haToken) ? { haUrl, haToken } : {};
        
        const response = await fetch(url('/api/test-home-assistant-connection'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await response.json();
        
        if (response.ok) {
          const showSuffix = ['manual', 'env', 'stored'].includes(data.authMode);
          const baseMessage = `${data.message}${showSuffix ? ` (using ${describeAuthSource(data.authMode)})` : ''}`;
          status.textContent = getStyledText('ui.connectionTest.connected');
          status.className = 'settings-inline-text status-success';
        } else {
          // Error - show error message
          status.textContent = getStyledText('ui.connectionTest.failed');
          status.className = 'settings-inline-text status-error';
        }
      } catch (error) {
        status.textContent = getStyledText('ui.connectionTest.failed');
        status.className = 'settings-inline-text status-error';
      }
    });

    // Backup now
    document.getElementById('backupNow').addEventListener('click', async () => {
      const backupStatus = document.getElementById('backupStatus');
      backupStatus.textContent = getStyledText('ui.backupNow.creating');
      backupStatus.className = 'settings-inline-text';
      
      try {
        const liveConfigPath = document.getElementById('liveConfigPath').value || '/config';
        const backupFolderPath = document.getElementById('backupFolderPath').value || '/backup';
        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        console.log('[backup-now-ui] Starting backup with paths:', { liveConfigPath, backupFolderPath, timezone });
        
        const response = await fetch(url('/api/backup-now'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            liveConfigPath: document.getElementById('liveConfigPath').value || '/config',
            backupFolderPath: document.getElementById('backupFolderPath').value || '/backup',
            timezone
          })
        });
        
        console.log('[backup-now-ui] Response status:', response.status);
        let data = null;
        try {
          data = await response.json();
        } catch (parseError) {
          console.warn('[backup-now-ui] Failed to parse response JSON:', parseError);
        }
        console.log('[backup-now-ui] Response data:', data);
        
        if (!response.ok) {
          const replacements = {
            path: data?.meta?.path || data?.path || backupFolderPath,
            parent: data?.meta?.parent
          };
          const friendly = getSettingsMessageFromCode(data?.errorCode, replacements);
          const fallback = applyTextStyle('Error: ' + (data?.error || 'Backup failed'), 'error');
          backupStatus.textContent = friendly || fallback;
          backupStatus.className = 'settings-inline-text status-error';
          return;
        }
        
        const successPath = data.path || backupFolderPath;
        backupStatus.textContent = getStyledText('ui.backupNow.successWithPath', { path: successPath });
        backupStatus.className = 'settings-inline-text status-success';
      } catch (error) {
        const friendly = getSettingsMessageFromCode(error?.code || 'unknown', { path: error?.meta?.path });
        backupStatus.textContent = friendly || applyTextStyle('Error: ' + (error?.message || 'Unknown error'), 'error');
        backupStatus.className = 'settings-inline-text status-error';
      }
    });

    // Schedule toggle
    document.getElementById('scheduleEnabled').addEventListener('change', (e) => {
      const isEnabled = e.target.checked;
      document.getElementById('scheduleOptions').style.display = isEnabled ? 'block' : 'none';
      document.getElementById('maxBackupsSection').style.display = isEnabled ? 'block' : 'none';
      
      // If schedule is disabled, also disable max backups
      if (!isEnabled) {
        document.getElementById('maxBackupsEnabled').checked = false;
        document.getElementById('maxBackupsOptions').style.display = 'none';
      }
    });

    // Max backups toggle
    document.getElementById('maxBackupsEnabled').addEventListener('change', (e) => {
      document.getElementById('maxBackupsOptions').style.display = e.target.checked ? 'block' : 'none';
    });


    document.getElementById('scheduleFrequency').addEventListener('change', (e) => {
      const freq = e.target.value;
      const isWeekly = freq === 'weekly';
      document.getElementById('scheduleTimeGroup').style.display = freq === 'hourly' ? 'none' : 'block';
      document.getElementById('scheduleDayGroup').style.display = isWeekly ? 'block' : 'none';
      
      document.getElementById('scheduleOptions').dataset.frequency = freq;
    });

    // Load schedule settings
    async function loadScheduleSettings() {
      try {
        const response = await fetch(url('/api/schedule-backup'));
        const data = await response.json();
        
        if (data.jobs && data.jobs['default-backup-job']) {
          const job = data.jobs['default-backup-job'];
          const isEnabled = job.enabled;
          document.getElementById('scheduleEnabled').checked = isEnabled;
          document.getElementById('scheduleOptions').style.display = isEnabled ? 'block' : 'none';
          document.getElementById('maxBackupsSection').style.display = isEnabled ? 'block' : 'none';
          
          const { frequency, time, day } = cronToSchedule(job.cronExpression);
          document.getElementById('scheduleFrequency').value = frequency;
          document.getElementById('scheduleTime').value = time;
          document.getElementById('scheduleDay').value = day || '0';
          
          // Set displays
          const isWeekly = frequency === 'weekly';
          document.getElementById('scheduleTimeGroup').style.display = frequency === 'hourly' ? 'none' : 'block';
          document.getElementById('scheduleDayGroup').style.display = isWeekly ? 'block' : 'none';
          
          // Adjust layout based on frequency
          document.getElementById('scheduleOptions').dataset.frequency = frequency;
          
          // Load max backups settings
          document.getElementById('maxBackupsEnabled').checked = job.maxBackupsEnabled || false;
          document.getElementById('maxBackupsOptions').style.display = (job.maxBackupsEnabled) ? 'block' : 'none';
          document.getElementById('maxBackupsCount').value = job.maxBackupsCount || 10;
        }
      } catch (error) {
        console.error('[loadScheduleSettings] Error:', error);
      }
    }

    // Cron helpers
    function scheduleToCron(frequency, time, day) {
      const [hour, minute] = time.split(':').map(Number);
      if (frequency === 'hourly') return '0 * * * *';
      if (frequency === 'daily') return `${minute} ${hour} * * *`;
      if (frequency === 'weekly') return `${minute} ${hour} * * ${day}`;
      return '0 0 * * *';
    }

    function cronToSchedule(cron) {
      const parts = cron.split(' ');
      if (parts.length !== 5) return { frequency: 'daily', time: '00:00', day: '0' };
      
      const [minute, hour, , , dayOfWeek] = parts;
      const time = `${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
      
      if (hour === '*') return { frequency: 'hourly', time: '00:00', day: '0' };
      if (dayOfWeek !== '*') return { frequency: 'weekly', time, day: dayOfWeek };
      return { frequency: 'daily', time, day: '0' };
    }

    // Diff modal handlers
    document.getElementById('closeDiff').addEventListener('click', () => {
      document.getElementById('diffModal').style.display = 'none';
    });
    
    document.getElementById('cancelDiff').addEventListener('click', () => {
      document.getElementById('diffModal').style.display = 'none';
    });

    // Initialize
    (async () => {
      updateEsphomeVisibility();
      await loadAppSettings();
      await waitForStrings();
      document.getElementById('itemsTitle').textContent = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      updatePlaceholders();
      loadBackups();
    })();

    // Parse unified diff format (git diff output) for Files mode
    function parseDiff(diffText) {
      if (!diffText || diffText.trim() === '') {
        return '<div class="diff-empty">No changes</div>';
      }

      const lines = diffText.split('\n');
      let html = '';

      for (let line of lines) {
        // Skip file headers (already shown in UI)
        if (line.startsWith('+++') || line.startsWith('---')) {
          continue;
        }

        // Determine line type and apply appropriate styling
        let className = 'diff-context';
        if (line.startsWith('+')) {
          className = 'diff-addition';
        } else if (line.startsWith('-')) {
          className = 'diff-deletion';
        } else if (line.startsWith('@@')) {
          className = 'diff-hunk-header';
        }

        const escapedLine = escapeHtml(line);
        html += `<div class="${className}">${escapedLine}</div>`;
      }

      return html;
    }

    // Generate split diff with paired columns
    function generateDiff(oldText, newText, options = {}) {
      if (!window.Diff) {
        return '<div class="diff-loading">Loading diff library...</div>';
      }

      const leftLabel = options.leftLabel || 'Live version';
      const rightLabel = options.rightLabel || 'Backup Version';
      const leftMeta = options.leftMeta || '';
      const rightMeta = options.rightMeta || '';
      const bannerText = options.bannerText || '';

      const diff = Diff.diffLines(oldText, newText);
      const MAX_CONTEXT_LINES = 12;

      const diffLines = [];
      let oldLineNum = 1;
      let newLineNum = 1;

      diff.forEach(part => {
        let lines = part.value.split('\n');
        if (lines.length && lines[lines.length - 1] === '') {
          lines.pop();
        }

        if (part.added) {
          lines.forEach(line => {
            diffLines.push({ type: 'added', text: line, oldLine: null, newLine: newLineNum });
            newLineNum++;
          });
        } else if (part.removed) {
          lines.forEach(line => {
            diffLines.push({ type: 'removed', text: line, oldLine: oldLineNum, newLine: null });
            oldLineNum++;
          });
        } else {
          lines.forEach(line => {
            diffLines.push({ type: 'context', text: line, oldLine: oldLineNum, newLine: newLineNum });
            oldLineNum++;
            newLineNum++;
          });
        }
      });

      const hunks = [];
      let index = 0;

      while (index < diffLines.length) {
        while (index < diffLines.length && diffLines[index].type === 'context') {
          index++;
        }

        if (index >= diffLines.length) break;

        let hunkStart = Math.max(0, index - MAX_CONTEXT_LINES);
        let hunkEnd = index;
        let postContextCount = 0;

        while (hunkEnd < diffLines.length) {
          const line = diffLines[hunkEnd];
          if (line.type === 'context') {
            postContextCount++;
            if (postContextCount > MAX_CONTEXT_LINES) {
              break;
            }
          } else {
            postContextCount = 0;
          }
          hunkEnd++;
        }

        const hunkLines = diffLines.slice(hunkStart, hunkEnd);
        const firstChangeIndex = hunkLines.findIndex(line => line.type !== 'context');

        const contextBefore = firstChangeIndex > 0 ? hunkLines.slice(0, firstChangeIndex) : [];
        const lines = firstChangeIndex >= 0 ? hunkLines.slice(firstChangeIndex) : hunkLines.slice();

        const oldLines = hunkLines.filter(line => line.oldLine !== null);
        const newLines = hunkLines.filter(line => line.newLine !== null);

        hunks.push({
          oldStart: oldLines.length ? oldLines[0].oldLine : 1,
          newStart: newLines.length ? newLines[0].newLine : 1,
          oldCount: oldLines.length,
          newCount: newLines.length,
          contextBefore,
          lines
        });

        index = hunkEnd;
      }

      if (!hunks.length) {
        return `
          <div class="diff-empty-state">
            <div class="diff-empty-card">
              <h3>No visible differences</h3>
              <p>Everything matches between backup and live.</p>
            </div>
          </div>
        `;
      }

      return `
        <div class="diff-banners-grid diff-banners-grid--standalone">
          <div class="diff-state-banner diff-state-banner-current diff-state-banner--header"><span class="diff-state-label">Current Version</span></div>
          ${bannerText ? `<div class="diff-state-banner diff-state-banner-changed diff-state-banner--header"><span class="diff-state-label">${escapeHtml(bannerText)}</span></div>` : '<div class="diff-state-banner diff-state-banner-empty diff-state-banner--header"></div>'}
        </div>
        <div class="diff-viewer-shell">
          <div class="diff-viewer-split">
            <div class="diff-hunks">
              ${hunks.map((hunk, index) => renderSplitHunk(hunk, index)).join('')}
            </div>
          </div>
        </div>
      `;
    }

    function renderSplitHunk(hunk, index) {
      const oldCount = hunk.oldCount || 1;
      const newCount = hunk.newCount || 1;
      const oldEnd = oldCount ? hunk.oldStart + oldCount - 1 : hunk.oldStart;
      const newEnd = newCount ? hunk.newStart + newCount - 1 : hunk.newStart;
      const summary = `Lines ${hunk.oldStart}${oldEnd !== hunk.oldStart ? `-${oldEnd}` : ''} → ${hunk.newStart}${newEnd !== hunk.newStart ? `-${newEnd}` : ''}`;
      const completeLines = [...(hunk.contextBefore || []), ...hunk.lines];
      const rowsHtml = renderSplitRows(completeLines);
      const contextLineCount = completeLines.filter(line => line.type === 'context').length;
      const hunkId = `diff-hunk-${index}`;
      const showLabel = 'Expand context ...';
      const hideLabel = 'Collapse context';
      const buttonHtml = contextLineCount
        ? `<button class="diff-context-toggle" type="button" data-show-label="${showLabel}" data-hide-label="${hideLabel}" aria-expanded="false" onclick="toggleHunkContext('${hunkId}', this)">${showLabel}</button>`
        : '';
      const hunkClasses = contextLineCount ? 'diff-hunk diff-hunk--context-collapsed' : 'diff-hunk';

      return `
        <div class="${hunkClasses}" id="${hunkId}">
          <div class="diff-hunk-content">
            ${rowsHtml}
          </div>
          <div class="diff-hunk-footer">
            <div class="diff-hunk-summary">${summary}</div>
            ${buttonHtml}
          </div>
        </div>
      `;
    }

    function renderSplitRows(lines) {
      const rows = [];
      let index = 0;

      while (index < lines.length) {
        const line = lines[index];

        if (line.type === 'context') {
          rows.push(renderSplitRow(
            {
              type: 'context',
              text: line.text,
              lineNumber: line.oldLine,
              marker: ''
            },
            {
              type: 'context',
              text: line.text,
              lineNumber: line.newLine,
              marker: ''
            }
          ));
          index++;
          continue;
        }

        if (line.type === 'removed') {
          const removed = [];
          const added = [];

          while (index < lines.length && lines[index].type === 'removed') {
            removed.push(lines[index]);
            index++;
          }

          while (index < lines.length && lines[index].type === 'added') {
            added.push(lines[index]);
            index++;
          }

          const maxRows = Math.max(removed.length, added.length);
          for (let i = 0; i < maxRows; i++) {
            rows.push(renderSplitRow(
              removed[i]
                ? {
                    type: 'removed',
                    text: removed[i].text,
                    lineNumber: removed[i].oldLine,
                    marker: '-'
                  }
                : {
                    type: 'empty',
                    text: '',
                    lineNumber: null,
                    marker: ''
                  },
              added[i]
                ? {
                    type: 'added',
                    text: added[i].text,
                    lineNumber: added[i].newLine,
                    marker: '+'
                  }
                : {
                    type: 'empty',
                    text: '',
                    lineNumber: null,
                    marker: ''
                  }
            ));
          }

          continue;
        }

        if (line.type === 'added') {
          const added = [];

          while (index < lines.length && lines[index].type === 'added') {
            added.push(lines[index]);
            index++;
          }

          added.forEach(entry => {
            rows.push(renderSplitRow(
              {
                type: 'empty',
                text: '',
                lineNumber: null,
                marker: ''
              },
              {
                type: 'added',
                text: entry.text,
                lineNumber: entry.newLine,
                marker: '+'
              }
            ));
          });

          continue;
        }

        rows.push(renderSplitRow(
          {
            type: line.type,
            text: line.text,
            lineNumber: line.oldLine,
            marker: ' '
          },
          {
            type: line.type,
            text: line.text,
            lineNumber: line.newLine,
            marker: ' '
          }
        ));
        index++;
      }

      return rows.join('');
    }

    function renderSplitRow(left, right) {
      return `
        <div class="diff-row ${left.type === 'context' && right.type === 'context' ? 'diff-row-context' : ''}">
          <div class="diff-cell diff-cell-left">
            ${renderLineContent(left, 'left')}
          </div>
          <div class="diff-cell diff-cell-right">
            ${renderLineContent(right, 'right')}
          </div>
        </div>
      `;
    }

    function renderLineContent(line, position) {
      if (line.type === 'empty') {
        return '<div class="diff-line diff-line-empty"></div>';
      }

      const marker = line.marker || (line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ');
      const lineNum = line.lineNumber || '';
      const lineClass = `diff-line diff-line-${line.type}`;

      return `
        <div class="${lineClass} diff-line-${position}">
          <span class="diff-line-marker">${marker}</span>
          <span class="diff-line-num">${lineNum}</span>
          <pre class="diff-line-text"><code>${escapeHtml(line.text)}</code></pre>
        </div>
      `;
    }

    function toggleHunkContext(hunkId, button) {
      const hunk = document.getElementById(hunkId);
      if (!hunk || !button) {
        return;
      }

      const collapsed = hunk.classList.toggle('diff-hunk--context-collapsed');
      if (collapsed) {
        button.textContent = button.dataset.showLabel;
        button.setAttribute('aria-expanded', 'false');
      } else {
        button.textContent = button.dataset.hideLabel || 'Hide context';
        button.setAttribute('aria-expanded', 'true');
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================================
    // FILES MODE FUNCTIONS
    // ============================================================

    async function loadFileTree() {
      console.log('[files] Loading file tree...');
      const treeContainer = document.getElementById('fileTree');
      treeContainer.innerHTML = '<p class="loading">Loading file tree...</p>';

      try {
        const response = await fetch(url('/api/git-file-tree'));
        const data = await response.json();

        if (!response.ok) {
          if (data.error && data.error.includes('Git mode is not enabled')) {
            treeContainer.innerHTML = `
              <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center; padding: 24px;">
                <div class="file-icon-container">
                  <svg class="file-icon" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                  </svg>
                </div>
                <p class="empty-state-message" style="margin-bottom: 8px;">Git mode is not enabled</p>
                <p style="color: #6b7280; font-size: 14px;">Enable Git mode in Settings to use file navigation</p>
              </div>
            `;
            return;
          }
          throw new Error(data.error || 'Failed to load file tree');
        }

        fileTreeData = data.tree;
        renderFileTree(data.tree);

        const fileCount = countFiles(data.tree);
        document.getElementById('fileTreeCount').textContent = `${fileCount} file${fileCount !== 1 ? 's' : ''}`;
      } catch (error) {
        console.error('[files] Error loading file tree:', error);
        treeContainer.innerHTML = `<p style="color: #ef4444; padding: 16px;">Error loading file tree: ${error.message}</p>`;
      }
    }

    function countFiles(node) {
      if (node.type === 'file') return 1;
      if (!node.children) return 0;
      return node.children.reduce((sum, child) => sum + countFiles(child), 0);
    }

    function renderFileTree(tree) {
      const treeContainer = document.getElementById('fileTree');
      treeContainer.innerHTML = '';

      if (!tree.children || tree.children.length === 0) {
        treeContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
              </svg>
            </div>
            <p class="empty-state-message">No files found in repository</p>
          </div>
        `;
        return;
      }

      const treeList = document.createElement('ul');
      treeList.className = 'file-tree-list';
      tree.children.forEach(node => {
        treeList.appendChild(createTreeNode(node));
      });
      treeContainer.appendChild(treeList);
    }

    function createTreeNode(node) {
      const li = document.createElement('li');
      li.className = 'file-tree-item';

      if (node.type === 'folder') {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'file-tree-folder';
        folderDiv.innerHTML = `
          <span class="file-tree-icon folder-icon">
            <svg class="folder-chevron" width="12" height="12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
            <svg class="folder-svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
            </svg>
          </span>
          <span class="file-tree-name">${escapeHtml(node.name)}</span>
        `;

        folderDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          li.classList.toggle('expanded');
        });

        li.appendChild(folderDiv);

        if (node.children && node.children.length > 0) {
          const childList = document.createElement('ul');
          childList.className = 'file-tree-list file-tree-children';
          node.children.forEach(child => {
            childList.appendChild(createTreeNode(child));
          });
          li.appendChild(childList);
        }
      } else {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'file-tree-file';
        fileDiv.dataset.path = node.path;
        fileDiv.innerHTML = `
          <span class="file-tree-icon">
            <svg class="file-svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
            </svg>
          </span>
          <span class="file-tree-name">${escapeHtml(node.name)}</span>
        `;

        fileDiv.addEventListener('click', () => {
          document.querySelectorAll('.file-tree-file').forEach(f => f.classList.remove('selected'));
          fileDiv.classList.add('selected');
          loadFileHistory(node.path, node.name);

          // Scroll the history panel (middle panel) to top for better UX
          const historyPanel = document.querySelector('.panel--files:nth-child(2)');
          if (historyPanel) {
            historyPanel.scrollTop = 0;
          }
        });

        li.appendChild(fileDiv);
      }

      return li;
    }

    async function loadFileHistory(filePath, fileName) {
      console.log(`[files] Loading history for ${filePath}`);
      selectedFilePath = filePath;
      selectedCommitHash = null;

      const historyContainer = document.getElementById('fileHistory');
      const titleEl = document.getElementById('fileHistoryTitle');
      const countEl = document.getElementById('fileHistoryCount');

      titleEl.textContent = fileName || filePath;
      countEl.textContent = 'Loading...';
      historyContainer.innerHTML = '<p class="loading">Loading file history...</p>';

      // Reset diff viewer
      document.getElementById('fileDiffTitle').textContent = 'Select a commit';
      document.getElementById('fileDiffSubtitle').textContent = '';
      document.getElementById('fileDiffViewer').innerHTML = `
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
          <div class="file-icon-container">
            <svg class="file-icon" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
          </div>
          <p class="empty-state-message">Select a commit to view changes</p>
        </div>
      `;

      try {
        const response = await fetch(url('/api/git-file-history'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filePath, limit: 100 })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to load file history');
        }

        fileHistoryData = data.commits;
        renderFileHistory(data.commits, fileName || filePath);
        countEl.textContent = `${data.commits.length} commit${data.commits.length !== 1 ? 's' : ''}`;
      } catch (error) {
        console.error('[files] Error loading file history:', error);
        historyContainer.innerHTML = `<p style="color: #ef4444; padding: 16px;">Error loading file history: ${error.message}</p>`;
        countEl.textContent = '';
      }
    }

    function renderFileHistory(commits, fileName) {
      const historyContainer = document.getElementById('fileHistory');

      if (!commits || commits.length === 0) {
        historyContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <p class="empty-state-message">No history found for this file</p>
          </div>
        `;
        return;
      }

      historyContainer.innerHTML = '';
      const timeline = document.createElement('div');
      timeline.className = 'file-timeline';

      commits.forEach((commit, index) => {
        const commitEl = document.createElement('div');
        commitEl.className = 'timeline-commit';
        commitEl.dataset.hash = commit.hash;

        const date = new Date(commit.date);
        const formattedDate = date.toLocaleString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });

        commitEl.innerHTML = `
          <div class="timeline-dot"></div>
          <div class="timeline-content">
            <div class="timeline-message">${escapeHtml(commit.message)}</div>
            <div class="timeline-meta">
              <span class="timeline-date">${formattedDate}</span>
              <span class="timeline-hash">${commit.hash.substring(0, 7)}</span>
            </div>
          </div>
        `;

        commitEl.addEventListener('click', () => {
          document.querySelectorAll('.timeline-commit').forEach(c => c.classList.remove('selected'));
          commitEl.classList.add('selected');
          loadFileDiff(commit.hash, selectedFilePath, fileName, commit.message, formattedDate);
        });

        timeline.appendChild(commitEl);
      });

      historyContainer.appendChild(timeline);
    }

    async function loadFileDiff(commitHash, filePath, fileName, commitMessage, commitDate) {
      console.log(`[files] Loading diff for ${filePath} at ${commitHash}`);
      selectedCommitHash = commitHash;

      const diffContainer = document.getElementById('fileDiffViewer');
      const titleEl = document.getElementById('fileDiffTitle');
      const subtitleEl = document.getElementById('fileDiffSubtitle');

      titleEl.textContent = fileName || filePath;
      subtitleEl.textContent = commitMessage;
      diffContainer.innerHTML = '<p class="loading">Loading diff...</p>';

      try {
        const response = await fetch(url('/api/git-diff'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ commitHash, filePath })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to load diff');
        }

        renderFileDiff(data.diff, fileName || filePath, commitDate);
      } catch (error) {
        console.error('[files] Error loading diff:', error);
        diffContainer.innerHTML = `<p style="color: #ef4444; padding: 16px;">Error loading diff: ${error.message}</p>`;
      }
    }

    function renderFileDiff(diffText, fileName, commitDate) {
      const diffContainer = document.getElementById('fileDiffViewer');

      if (!diffText || diffText.trim() === '') {
        diffContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
            <div class="file-icon-container">
              <svg class="file-icon" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
            </div>
            <p class="empty-state-message">No changes in this commit</p>
          </div>
        `;
        return;
      }

      // Parse and render diff (reuse existing diff rendering logic)
      const diffHtml = parseDiff(diffText);
      diffContainer.innerHTML = `
        <div class="diff-container">
          <div class="diff-file">
            <div class="diff-file-header">
              <svg style="width: 16px; height: 16px; margin-right: 8px;" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
              ${escapeHtml(fileName)}
            </div>
            <div class="diff-content">${diffHtml}</div>
          </div>
        </div>
      `;

      // Attach context toggle handlers
      diffContainer.querySelectorAll('.diff-hunk-toggle').forEach(button => {
        button.addEventListener('click', () => toggleHunkContext(button));
      });
    }

    // Include js-yaml for client-side YAML parsing
    const yamlScript = document.createElement('script');
    yamlScript.src = 'https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js';
    document.head.appendChild(yamlScript);

    // Include diff library for line-by-line comparison
    const diffScript = document.createElement('script');
    diffScript.src = 'https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js';
    document.head.appendChild(diffScript);
  </script>
</body>
</html>
